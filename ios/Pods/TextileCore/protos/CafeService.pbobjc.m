// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cafe_service.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "CafeService.pbobjc.h"
#import "Model.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - CafeServiceRoot

@implementation CafeServiceRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - CafeServiceRoot_FileDescriptor

static GPBFileDescriptor *CafeServiceRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - CafeChallenge

@implementation CafeChallenge

@dynamic address;

typedef struct CafeChallenge__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
} CafeChallenge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = CafeChallenge_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeChallenge__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeChallenge class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeChallenge__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeNonce

@implementation CafeNonce

@dynamic value;

typedef struct CafeNonce__storage_ {
  uint32_t _has_storage_[1];
  NSString *value;
} CafeNonce__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = CafeNonce_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeNonce__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeNonce class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeNonce__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeRegistration

@implementation CafeRegistration

@dynamic address;
@dynamic value;
@dynamic nonce;
@dynamic sig;
@dynamic token;

typedef struct CafeRegistration__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *value;
  NSString *nonce;
  NSData *sig;
  NSString *token;
} CafeRegistration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = CafeRegistration_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeRegistration__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = CafeRegistration_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeRegistration__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = CafeRegistration_FieldNumber_Nonce,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CafeRegistration__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sig",
        .dataTypeSpecific.className = NULL,
        .number = CafeRegistration_FieldNumber_Sig,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CafeRegistration__storage_, sig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = CafeRegistration_FieldNumber_Token,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CafeRegistration__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeRegistration class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeRegistration__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeDeregistration

@implementation CafeDeregistration

@dynamic token;

typedef struct CafeDeregistration__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} CafeDeregistration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = CafeDeregistration_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeDeregistration__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeDeregistration class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeDeregistration__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeDeregistrationAck

@implementation CafeDeregistrationAck

@dynamic id_p;

typedef struct CafeDeregistrationAck__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
} CafeDeregistrationAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeDeregistrationAck_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeDeregistrationAck__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeDeregistrationAck class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeDeregistrationAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeRefreshSession

@implementation CafeRefreshSession

@dynamic access;
@dynamic refresh;

typedef struct CafeRefreshSession__storage_ {
  uint32_t _has_storage_[1];
  NSString *access;
  NSString *refresh;
} CafeRefreshSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "access",
        .dataTypeSpecific.className = NULL,
        .number = CafeRefreshSession_FieldNumber_Access,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeRefreshSession__storage_, access),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refresh",
        .dataTypeSpecific.className = NULL,
        .number = CafeRefreshSession_FieldNumber_Refresh,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeRefreshSession__storage_, refresh),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeRefreshSession class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeRefreshSession__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafePublishPeer

@implementation CafePublishPeer

@dynamic token;
@dynamic hasPeer, peer;

typedef struct CafePublishPeer__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  Peer *peer;
} CafePublishPeer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = CafePublishPeer_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafePublishPeer__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "peer",
        .dataTypeSpecific.className = GPBStringifySymbol(Peer),
        .number = CafePublishPeer_FieldNumber_Peer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafePublishPeer__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafePublishPeer class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafePublishPeer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafePublishPeerAck

@implementation CafePublishPeerAck

@dynamic id_p;

typedef struct CafePublishPeerAck__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
} CafePublishPeerAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafePublishPeerAck_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafePublishPeerAck__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafePublishPeerAck class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafePublishPeerAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeStore

@implementation CafeStore

@dynamic token;
@dynamic cidsArray, cidsArray_Count;

typedef struct CafeStore__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  NSMutableArray *cidsArray;
} CafeStore__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = CafeStore_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeStore__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cidsArray",
        .dataTypeSpecific.className = NULL,
        .number = CafeStore_FieldNumber_CidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CafeStore__storage_, cidsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeStore class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeStore__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeStoreAck

@implementation CafeStoreAck

@dynamic id_p;

typedef struct CafeStoreAck__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
} CafeStoreAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeStoreAck_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeStoreAck__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeStoreAck class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeStoreAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeUnstore

@implementation CafeUnstore

@dynamic token;
@dynamic cidsArray, cidsArray_Count;

typedef struct CafeUnstore__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  NSMutableArray *cidsArray;
} CafeUnstore__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = CafeUnstore_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeUnstore__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cidsArray",
        .dataTypeSpecific.className = NULL,
        .number = CafeUnstore_FieldNumber_CidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CafeUnstore__storage_, cidsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeUnstore class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeUnstore__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeUnstoreAck

@implementation CafeUnstoreAck

@dynamic cidsArray, cidsArray_Count;

typedef struct CafeUnstoreAck__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cidsArray;
} CafeUnstoreAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cidsArray",
        .dataTypeSpecific.className = NULL,
        .number = CafeUnstoreAck_FieldNumber_CidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CafeUnstoreAck__storage_, cidsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeUnstoreAck class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeUnstoreAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeObjectList

@implementation CafeObjectList

@dynamic cidsArray, cidsArray_Count;

typedef struct CafeObjectList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cidsArray;
} CafeObjectList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cidsArray",
        .dataTypeSpecific.className = NULL,
        .number = CafeObjectList_FieldNumber_CidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CafeObjectList__storage_, cidsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeObjectList class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeObjectList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeObject

@implementation CafeObject

@dynamic token;
@dynamic cid;
@dynamic data_p;
@dynamic node;

typedef struct CafeObject__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  NSString *cid;
  NSData *data_p;
  NSData *node;
} CafeObject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = CafeObject_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeObject__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = CafeObject_FieldNumber_Cid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeObject__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeObject_FieldNumber_Data_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CafeObject__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "node",
        .dataTypeSpecific.className = NULL,
        .number = CafeObject_FieldNumber_Node,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CafeObject__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeObject class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeObject__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeStoreThread

@implementation CafeStoreThread

@dynamic token;
@dynamic id_p;
@dynamic ciphertext;

typedef struct CafeStoreThread__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  NSString *id_p;
  NSData *ciphertext;
} CafeStoreThread__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = CafeStoreThread_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeStoreThread__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeStoreThread_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeStoreThread__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ciphertext",
        .dataTypeSpecific.className = NULL,
        .number = CafeStoreThread_FieldNumber_Ciphertext,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CafeStoreThread__storage_, ciphertext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeStoreThread class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeStoreThread__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeStoreThreadAck

@implementation CafeStoreThreadAck

@dynamic id_p;

typedef struct CafeStoreThreadAck__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
} CafeStoreThreadAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeStoreThreadAck_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeStoreThreadAck__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeStoreThreadAck class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeStoreThreadAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeUnstoreThread

@implementation CafeUnstoreThread

@dynamic token;
@dynamic id_p;

typedef struct CafeUnstoreThread__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  NSString *id_p;
} CafeUnstoreThread__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = CafeUnstoreThread_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeUnstoreThread__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeUnstoreThread_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeUnstoreThread__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeUnstoreThread class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeUnstoreThread__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeUnstoreThreadAck

@implementation CafeUnstoreThreadAck

@dynamic id_p;

typedef struct CafeUnstoreThreadAck__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
} CafeUnstoreThreadAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeUnstoreThreadAck_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeUnstoreThreadAck__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeUnstoreThreadAck class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeUnstoreThreadAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeDeliverMessage

@implementation CafeDeliverMessage

@dynamic id_p;
@dynamic client;
@dynamic env;

typedef struct CafeDeliverMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *client;
  NSData *env;
} CafeDeliverMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeDeliverMessage_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeDeliverMessage__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "client",
        .dataTypeSpecific.className = NULL,
        .number = CafeDeliverMessage_FieldNumber_Client,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeDeliverMessage__storage_, client),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "env",
        .dataTypeSpecific.className = NULL,
        .number = CafeDeliverMessage_FieldNumber_Env,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CafeDeliverMessage__storage_, env),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeDeliverMessage class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeDeliverMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeCheckMessages

@implementation CafeCheckMessages

@dynamic token;

typedef struct CafeCheckMessages__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} CafeCheckMessages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = CafeCheckMessages_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeCheckMessages__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeCheckMessages class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeCheckMessages__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeMessages

@implementation CafeMessages

@dynamic messagesArray, messagesArray_Count;

typedef struct CafeMessages__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *messagesArray;
} CafeMessages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CafeMessage),
        .number = CafeMessages_FieldNumber_MessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CafeMessages__storage_, messagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeMessages class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeMessages__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeDeleteMessages

@implementation CafeDeleteMessages

@dynamic token;

typedef struct CafeDeleteMessages__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} CafeDeleteMessages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = CafeDeleteMessages_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeDeleteMessages__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeDeleteMessages class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeDeleteMessages__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeDeleteMessagesAck

@implementation CafeDeleteMessagesAck

@dynamic more;

typedef struct CafeDeleteMessagesAck__storage_ {
  uint32_t _has_storage_[1];
} CafeDeleteMessagesAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "more",
        .dataTypeSpecific.className = NULL,
        .number = CafeDeleteMessagesAck_FieldNumber_More,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeDeleteMessagesAck class]
                                     rootClass:[CafeServiceRoot class]
                                          file:CafeServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeDeleteMessagesAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
