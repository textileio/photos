// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Model.pbobjc.h"
#import "Message.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ModelRoot

@implementation ModelRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ModelRoot_FileDescriptor

static GPBFileDescriptor *ModelRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Peer

@implementation Peer

@dynamic id_p;
@dynamic address;
@dynamic name;
@dynamic avatar;
@dynamic inboxesArray, inboxesArray_Count;
@dynamic hasCreated, created;
@dynamic hasUpdated, updated;

typedef struct Peer__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *address;
  NSString *name;
  NSString *avatar;
  NSMutableArray *inboxesArray;
  GPBTimestamp *created;
  GPBTimestamp *updated;
} Peer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Peer__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Peer__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Peer__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_Avatar,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Peer__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inboxesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Cafe),
        .number = Peer_FieldNumber_InboxesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Peer__storage_, inboxesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = Peer_FieldNumber_Created,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Peer__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updated",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = Peer_FieldNumber_Updated,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Peer__storage_, updated),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Peer class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Peer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerList

@implementation PeerList

@dynamic itemsArray, itemsArray_Count;

typedef struct PeerList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} PeerList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Peer),
        .number = PeerList_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PeerList__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerList class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - User

@implementation User

@dynamic address;
@dynamic name;
@dynamic avatar;

typedef struct User__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *name;
  NSString *avatar;
} User__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(User__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(User__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(User__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[User class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(User__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Contact

@implementation Contact

@dynamic address;
@dynamic name;
@dynamic avatar;
@dynamic peersArray, peersArray_Count;
@dynamic threadsArray, threadsArray_Count;

typedef struct Contact__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *name;
  NSString *avatar;
  NSMutableArray *peersArray;
  NSMutableArray *threadsArray;
} Contact__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Contact_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Contact__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Contact_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Contact__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = Contact_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Contact__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "peersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Peer),
        .number = Contact_FieldNumber_PeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Contact__storage_, peersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "threadsArray",
        .dataTypeSpecific.className = NULL,
        .number = Contact_FieldNumber_ThreadsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Contact__storage_, threadsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Contact class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Contact__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContactList

@implementation ContactList

@dynamic itemsArray, itemsArray_Count;

typedef struct ContactList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} ContactList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Contact),
        .number = ContactList_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ContactList__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContactList class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContactList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Thread

@implementation Thread

@dynamic id_p;
@dynamic key;
@dynamic sk;
@dynamic name;
@dynamic schema;
@dynamic initiator;
@dynamic type;
@dynamic sharing;
@dynamic membersArray, membersArray_Count;
@dynamic state;
@dynamic head;
@dynamic hasHeadBlock, headBlock;
@dynamic hasSchemaNode, schemaNode;
@dynamic blockCount;
@dynamic peerCount;

typedef struct Thread__storage_ {
  uint32_t _has_storage_[1];
  Thread_Type type;
  Thread_Sharing sharing;
  Thread_State state;
  int32_t blockCount;
  int32_t peerCount;
  NSString *id_p;
  NSString *key;
  NSData *sk;
  NSString *name;
  NSString *schema;
  NSString *initiator;
  NSMutableArray *membersArray;
  NSString *head;
  Block *headBlock;
  Node *schemaNode;
} Thread__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Thread_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Thread__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = Thread_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Thread__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sk",
        .dataTypeSpecific.className = NULL,
        .number = Thread_FieldNumber_Sk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Thread__storage_, sk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Thread_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Thread__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "schema",
        .dataTypeSpecific.className = NULL,
        .number = Thread_FieldNumber_Schema,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Thread__storage_, schema),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "initiator",
        .dataTypeSpecific.className = NULL,
        .number = Thread_FieldNumber_Initiator,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Thread__storage_, initiator),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Thread_Type_EnumDescriptor,
        .number = Thread_FieldNumber_Type,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Thread__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sharing",
        .dataTypeSpecific.enumDescFunc = Thread_Sharing_EnumDescriptor,
        .number = Thread_FieldNumber_Sharing,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Thread__storage_, sharing),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "membersArray",
        .dataTypeSpecific.className = NULL,
        .number = Thread_FieldNumber_MembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Thread__storage_, membersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = Thread_State_EnumDescriptor,
        .number = Thread_FieldNumber_State,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Thread__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "head",
        .dataTypeSpecific.className = NULL,
        .number = Thread_FieldNumber_Head,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Thread__storage_, head),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headBlock",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = Thread_FieldNumber_HeadBlock,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Thread__storage_, headBlock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "schemaNode",
        .dataTypeSpecific.className = GPBStringifySymbol(Node),
        .number = Thread_FieldNumber_SchemaNode,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Thread__storage_, schemaNode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockCount",
        .dataTypeSpecific.className = NULL,
        .number = Thread_FieldNumber_BlockCount,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Thread__storage_, blockCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "peerCount",
        .dataTypeSpecific.className = NULL,
        .number = Thread_FieldNumber_PeerCount,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Thread__storage_, peerCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Thread class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Thread__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Thread_Type_RawValue(Thread *message) {
  GPBDescriptor *descriptor = [Thread descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Thread_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetThread_Type_RawValue(Thread *message, int32_t value) {
  GPBDescriptor *descriptor = [Thread descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Thread_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t Thread_Sharing_RawValue(Thread *message) {
  GPBDescriptor *descriptor = [Thread descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Thread_FieldNumber_Sharing];
  return GPBGetMessageInt32Field(message, field);
}

void SetThread_Sharing_RawValue(Thread *message, int32_t value) {
  GPBDescriptor *descriptor = [Thread descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Thread_FieldNumber_Sharing];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t Thread_State_RawValue(Thread *message) {
  GPBDescriptor *descriptor = [Thread descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Thread_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetThread_State_RawValue(Thread *message, int32_t value) {
  GPBDescriptor *descriptor = [Thread descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Thread_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Thread_Type

GPBEnumDescriptor *Thread_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Private\000ReadOnly\000Public\000Open\000";
    static const int32_t values[] = {
        Thread_Type_Private,
        Thread_Type_ReadOnly,
        Thread_Type_Public,
        Thread_Type_Open,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Thread_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Thread_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Thread_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case Thread_Type_Private:
    case Thread_Type_ReadOnly:
    case Thread_Type_Public:
    case Thread_Type_Open:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Thread_Sharing

GPBEnumDescriptor *Thread_Sharing_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NotShared\000InviteOnly\000Shared\000";
    static const int32_t values[] = {
        Thread_Sharing_NotShared,
        Thread_Sharing_InviteOnly,
        Thread_Sharing_Shared,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Thread_Sharing)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Thread_Sharing_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Thread_Sharing_IsValidValue(int32_t value__) {
  switch (value__) {
    case Thread_Sharing_NotShared:
    case Thread_Sharing_InviteOnly:
    case Thread_Sharing_Shared:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Thread_State

GPBEnumDescriptor *Thread_State_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LoadingTail\000Loaded\000LoadingHead\000";
    static const int32_t values[] = {
        Thread_State_LoadingTail,
        Thread_State_Loaded,
        Thread_State_LoadingHead,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Thread_State)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Thread_State_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Thread_State_IsValidValue(int32_t value__) {
  switch (value__) {
    case Thread_State_LoadingTail:
    case Thread_State_Loaded:
    case Thread_State_LoadingHead:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ThreadList

@implementation ThreadList

@dynamic itemsArray, itemsArray_Count;

typedef struct ThreadList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} ThreadList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Thread),
        .number = ThreadList_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ThreadList__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ThreadList class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ThreadList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ThreadPeer

@implementation ThreadPeer

@dynamic id_p;
@dynamic thread;
@dynamic welcomed;

typedef struct ThreadPeer__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *thread;
} ThreadPeer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ThreadPeer_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ThreadPeer__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thread",
        .dataTypeSpecific.className = NULL,
        .number = ThreadPeer_FieldNumber_Thread,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ThreadPeer__storage_, thread),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "welcomed",
        .dataTypeSpecific.className = NULL,
        .number = ThreadPeer_FieldNumber_Welcomed,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ThreadPeer class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ThreadPeer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Block

@implementation Block

@dynamic id_p;
@dynamic thread;
@dynamic author;
@dynamic type;
@dynamic hasDate, date;
@dynamic parentsArray, parentsArray_Count;
@dynamic target;
@dynamic body;
@dynamic hasUser, user;

typedef struct Block__storage_ {
  uint32_t _has_storage_[1];
  Block_BlockType type;
  NSString *id_p;
  NSString *thread;
  NSString *author;
  GPBTimestamp *date;
  NSMutableArray *parentsArray;
  NSString *target;
  NSString *body;
  User *user;
} Block__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Block_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Block__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thread",
        .dataTypeSpecific.className = NULL,
        .number = Block_FieldNumber_Thread,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Block__storage_, thread),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "author",
        .dataTypeSpecific.className = NULL,
        .number = Block_FieldNumber_Author,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Block__storage_, author),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Block_BlockType_EnumDescriptor,
        .number = Block_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Block__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = Block_FieldNumber_Date,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Block__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "parentsArray",
        .dataTypeSpecific.className = NULL,
        .number = Block_FieldNumber_ParentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Block__storage_, parentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "target",
        .dataTypeSpecific.className = NULL,
        .number = Block_FieldNumber_Target,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Block__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = Block_FieldNumber_Body,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Block__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = Block_FieldNumber_User,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Block__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Block class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Block__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Block_Type_RawValue(Block *message) {
  GPBDescriptor *descriptor = [Block descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Block_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetBlock_Type_RawValue(Block *message, int32_t value) {
  GPBDescriptor *descriptor = [Block descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Block_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Block_BlockType

GPBEnumDescriptor *Block_BlockType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Merge\000Ignore\000Flag\000Join\000Announce\000Leave\000Te"
        "xt\000Files\000Comment\000Like\000Add\000";
    static const int32_t values[] = {
        Block_BlockType_Merge,
        Block_BlockType_Ignore,
        Block_BlockType_Flag,
        Block_BlockType_Join,
        Block_BlockType_Announce,
        Block_BlockType_Leave,
        Block_BlockType_Text,
        Block_BlockType_Files,
        Block_BlockType_Comment,
        Block_BlockType_Like,
        Block_BlockType_Add,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Block_BlockType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Block_BlockType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Block_BlockType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Block_BlockType_Merge:
    case Block_BlockType_Ignore:
    case Block_BlockType_Flag:
    case Block_BlockType_Join:
    case Block_BlockType_Announce:
    case Block_BlockType_Leave:
    case Block_BlockType_Text:
    case Block_BlockType_Files:
    case Block_BlockType_Comment:
    case Block_BlockType_Like:
    case Block_BlockType_Add:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BlockList

@implementation BlockList

@dynamic itemsArray, itemsArray_Count;

typedef struct BlockList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} BlockList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = BlockList_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockList__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockList class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockMessage

@implementation BlockMessage

@dynamic id_p;
@dynamic peer;
@dynamic hasEnv, env;
@dynamic hasDate, date;

typedef struct BlockMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *peer;
  Envelope *env;
  GPBTimestamp *date;
} BlockMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = BlockMessage_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockMessage__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "peer",
        .dataTypeSpecific.className = NULL,
        .number = BlockMessage_FieldNumber_Peer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "env",
        .dataTypeSpecific.className = GPBStringifySymbol(Envelope),
        .number = BlockMessage_FieldNumber_Env,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockMessage__storage_, env),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = BlockMessage_FieldNumber_Date,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlockMessage__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockMessage class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Invite

@implementation Invite

@dynamic id_p;
@dynamic block;
@dynamic name;
@dynamic hasInviter, inviter;
@dynamic hasDate, date;

typedef struct Invite__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSData *block;
  NSString *name;
  Peer *inviter;
  GPBTimestamp *date;
} Invite__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Invite_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Invite__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "block",
        .dataTypeSpecific.className = NULL,
        .number = Invite_FieldNumber_Block,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Invite__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Invite_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Invite__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inviter",
        .dataTypeSpecific.className = GPBStringifySymbol(Peer),
        .number = Invite_FieldNumber_Inviter,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Invite__storage_, inviter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = Invite_FieldNumber_Date,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Invite__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Invite class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Invite__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InviteList

@implementation InviteList

@dynamic itemsArray, itemsArray_Count;

typedef struct InviteList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} InviteList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Invite),
        .number = InviteList_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InviteList__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InviteList class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InviteList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FileIndex

@implementation FileIndex

@dynamic mill;
@dynamic checksum;
@dynamic source;
@dynamic opts;
@dynamic hash_p;
@dynamic key;
@dynamic media;
@dynamic name;
@dynamic size;
@dynamic hasAdded, added;
@dynamic hasMeta, meta;
@dynamic targetsArray, targetsArray_Count;

typedef struct FileIndex__storage_ {
  uint32_t _has_storage_[1];
  NSString *mill;
  NSString *checksum;
  NSString *source;
  NSString *opts;
  NSString *hash_p;
  NSString *key;
  NSString *media;
  NSString *name;
  GPBTimestamp *added;
  GPBStruct *meta;
  NSMutableArray *targetsArray;
  int64_t size;
} FileIndex__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mill",
        .dataTypeSpecific.className = NULL,
        .number = FileIndex_FieldNumber_Mill,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FileIndex__storage_, mill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "checksum",
        .dataTypeSpecific.className = NULL,
        .number = FileIndex_FieldNumber_Checksum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FileIndex__storage_, checksum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = FileIndex_FieldNumber_Source,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FileIndex__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opts",
        .dataTypeSpecific.className = NULL,
        .number = FileIndex_FieldNumber_Opts,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FileIndex__storage_, opts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = FileIndex_FieldNumber_Hash_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FileIndex__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = FileIndex_FieldNumber_Key,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FileIndex__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "media",
        .dataTypeSpecific.className = NULL,
        .number = FileIndex_FieldNumber_Media,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FileIndex__storage_, media),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = FileIndex_FieldNumber_Name,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FileIndex__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = FileIndex_FieldNumber_Size,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(FileIndex__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "added",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = FileIndex_FieldNumber_Added,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(FileIndex__storage_, added),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBStruct),
        .number = FileIndex_FieldNumber_Meta,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(FileIndex__storage_, meta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "targetsArray",
        .dataTypeSpecific.className = NULL,
        .number = FileIndex_FieldNumber_TargetsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FileIndex__storage_, targetsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FileIndex class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FileIndex__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Node

@implementation Node

@dynamic name;
@dynamic pin;
@dynamic plaintext;
@dynamic mill;
@dynamic opts, opts_Count;
@dynamic hasJsonSchema, jsonSchema;
@dynamic links, links_Count;

typedef struct Node__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *mill;
  NSMutableDictionary *opts;
  GPBStruct *jsonSchema;
  NSMutableDictionary *links;
} Node__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Node_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Node__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pin",
        .dataTypeSpecific.className = NULL,
        .number = Node_FieldNumber_Pin,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "plaintext",
        .dataTypeSpecific.className = NULL,
        .number = Node_FieldNumber_Plaintext,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "mill",
        .dataTypeSpecific.className = NULL,
        .number = Node_FieldNumber_Mill,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Node__storage_, mill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opts",
        .dataTypeSpecific.className = NULL,
        .number = Node_FieldNumber_Opts,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Node__storage_, opts),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonSchema",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBStruct),
        .number = Node_FieldNumber_JsonSchema,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Node__storage_, jsonSchema),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "links",
        .dataTypeSpecific.className = GPBStringifySymbol(Link),
        .number = Node_FieldNumber_Links,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Node__storage_, links),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Node class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Node__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Link

@implementation Link

@dynamic use;
@dynamic pin;
@dynamic plaintext;
@dynamic mill;
@dynamic opts, opts_Count;
@dynamic hasJsonSchema, jsonSchema;

typedef struct Link__storage_ {
  uint32_t _has_storage_[1];
  NSString *use;
  NSString *mill;
  NSMutableDictionary *opts;
  GPBStruct *jsonSchema;
} Link__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "use",
        .dataTypeSpecific.className = NULL,
        .number = Link_FieldNumber_Use,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Link__storage_, use),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pin",
        .dataTypeSpecific.className = NULL,
        .number = Link_FieldNumber_Pin,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "plaintext",
        .dataTypeSpecific.className = NULL,
        .number = Link_FieldNumber_Plaintext,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "mill",
        .dataTypeSpecific.className = NULL,
        .number = Link_FieldNumber_Mill,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Link__storage_, mill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opts",
        .dataTypeSpecific.className = NULL,
        .number = Link_FieldNumber_Opts,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Link__storage_, opts),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonSchema",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBStruct),
        .number = Link_FieldNumber_JsonSchema,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Link__storage_, jsonSchema),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Link class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Link__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Notification

@implementation Notification

@dynamic id_p;
@dynamic hasDate, date;
@dynamic actor;
@dynamic subject;
@dynamic subjectDesc;
@dynamic block;
@dynamic target;
@dynamic type;
@dynamic body;
@dynamic read;
@dynamic hasUser, user;

typedef struct Notification__storage_ {
  uint32_t _has_storage_[1];
  Notification_Type type;
  NSString *id_p;
  GPBTimestamp *date;
  NSString *actor;
  NSString *subject;
  NSString *subjectDesc;
  NSString *block;
  NSString *target;
  NSString *body;
  User *user;
} Notification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Notification_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Notification__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = Notification_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Notification__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actor",
        .dataTypeSpecific.className = NULL,
        .number = Notification_FieldNumber_Actor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Notification__storage_, actor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subject",
        .dataTypeSpecific.className = NULL,
        .number = Notification_FieldNumber_Subject,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Notification__storage_, subject),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subjectDesc",
        .dataTypeSpecific.className = NULL,
        .number = Notification_FieldNumber_SubjectDesc,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Notification__storage_, subjectDesc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "block",
        .dataTypeSpecific.className = NULL,
        .number = Notification_FieldNumber_Block,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Notification__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "target",
        .dataTypeSpecific.className = NULL,
        .number = Notification_FieldNumber_Target,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Notification__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Notification_Type_EnumDescriptor,
        .number = Notification_FieldNumber_Type,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Notification__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = Notification_FieldNumber_Body,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Notification__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "read",
        .dataTypeSpecific.className = NULL,
        .number = Notification_FieldNumber_Read,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = Notification_FieldNumber_User,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Notification__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Notification class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Notification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Notification_Type_RawValue(Notification *message) {
  GPBDescriptor *descriptor = [Notification descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Notification_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetNotification_Type_RawValue(Notification *message, int32_t value) {
  GPBDescriptor *descriptor = [Notification descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Notification_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Notification_Type

GPBEnumDescriptor *Notification_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "InviteReceived\000AccountPeerJoined\000PeerJoi"
        "ned\000PeerLeft\000MessageAdded\000FilesAdded\000Com"
        "mentAdded\000LikeAdded\000";
    static const int32_t values[] = {
        Notification_Type_InviteReceived,
        Notification_Type_AccountPeerJoined,
        Notification_Type_PeerJoined,
        Notification_Type_PeerLeft,
        Notification_Type_MessageAdded,
        Notification_Type_FilesAdded,
        Notification_Type_CommentAdded,
        Notification_Type_LikeAdded,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Notification_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Notification_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Notification_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case Notification_Type_InviteReceived:
    case Notification_Type_AccountPeerJoined:
    case Notification_Type_PeerJoined:
    case Notification_Type_PeerLeft:
    case Notification_Type_MessageAdded:
    case Notification_Type_FilesAdded:
    case Notification_Type_CommentAdded:
    case Notification_Type_LikeAdded:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - NotificationList

@implementation NotificationList

@dynamic itemsArray, itemsArray_Count;

typedef struct NotificationList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} NotificationList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Notification),
        .number = NotificationList_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NotificationList__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NotificationList class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NotificationList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Cafe

@implementation Cafe

@dynamic peer;
@dynamic address;
@dynamic api;
@dynamic protocol;
@dynamic node;
@dynamic URL;
@dynamic swarmArray, swarmArray_Count;

typedef struct Cafe__storage_ {
  uint32_t _has_storage_[1];
  NSString *peer;
  NSString *address;
  NSString *api;
  NSString *protocol;
  NSString *node;
  NSString *URL;
  NSMutableArray *swarmArray;
} Cafe__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.className = NULL,
        .number = Cafe_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Cafe__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Cafe_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Cafe__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "api",
        .dataTypeSpecific.className = NULL,
        .number = Cafe_FieldNumber_Api,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Cafe__storage_, api),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "protocol",
        .dataTypeSpecific.className = NULL,
        .number = Cafe_FieldNumber_Protocol,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Cafe__storage_, protocol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "node",
        .dataTypeSpecific.className = NULL,
        .number = Cafe_FieldNumber_Node,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Cafe__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = Cafe_FieldNumber_URL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Cafe__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "swarmArray",
        .dataTypeSpecific.className = NULL,
        .number = Cafe_FieldNumber_SwarmArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Cafe__storage_, swarmArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Cafe class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Cafe__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\006!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeSession

@implementation CafeSession

@dynamic id_p;
@dynamic access;
@dynamic hasExp, exp;
@dynamic refresh;
@dynamic hasRexp, rexp;
@dynamic subject;
@dynamic type;
@dynamic hasCafe, cafe;

typedef struct CafeSession__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *access;
  GPBTimestamp *exp;
  NSString *refresh;
  GPBTimestamp *rexp;
  NSString *subject;
  NSString *type;
  Cafe *cafe;
} CafeSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeSession_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeSession__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "access",
        .dataTypeSpecific.className = NULL,
        .number = CafeSession_FieldNumber_Access,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeSession__storage_, access),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "exp",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = CafeSession_FieldNumber_Exp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CafeSession__storage_, exp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "refresh",
        .dataTypeSpecific.className = NULL,
        .number = CafeSession_FieldNumber_Refresh,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CafeSession__storage_, refresh),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rexp",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = CafeSession_FieldNumber_Rexp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CafeSession__storage_, rexp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "subject",
        .dataTypeSpecific.className = NULL,
        .number = CafeSession_FieldNumber_Subject,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CafeSession__storage_, subject),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = CafeSession_FieldNumber_Type,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CafeSession__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cafe",
        .dataTypeSpecific.className = GPBStringifySymbol(Cafe),
        .number = CafeSession_FieldNumber_Cafe,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(CafeSession__storage_, cafe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeSession class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeSession__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeSessionList

@implementation CafeSessionList

@dynamic itemsArray, itemsArray_Count;

typedef struct CafeSessionList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} CafeSessionList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CafeSession),
        .number = CafeSessionList_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CafeSessionList__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeSessionList class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeSessionList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeRequest

@implementation CafeRequest

@dynamic id_p;
@dynamic peer;
@dynamic target;
@dynamic hasCafe, cafe;
@dynamic type;
@dynamic hasDate, date;

typedef struct CafeRequest__storage_ {
  uint32_t _has_storage_[1];
  CafeRequest_Type type;
  NSString *id_p;
  NSString *peer;
  NSString *target;
  Cafe *cafe;
  GPBTimestamp *date;
} CafeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeRequest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeRequest__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "peer",
        .dataTypeSpecific.className = NULL,
        .number = CafeRequest_FieldNumber_Peer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeRequest__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "target",
        .dataTypeSpecific.className = NULL,
        .number = CafeRequest_FieldNumber_Target,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CafeRequest__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cafe",
        .dataTypeSpecific.className = GPBStringifySymbol(Cafe),
        .number = CafeRequest_FieldNumber_Cafe,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CafeRequest__storage_, cafe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = CafeRequest_Type_EnumDescriptor,
        .number = CafeRequest_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CafeRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = CafeRequest_FieldNumber_Date,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CafeRequest__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeRequest class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CafeRequest_Type_RawValue(CafeRequest *message) {
  GPBDescriptor *descriptor = [CafeRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CafeRequest_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetCafeRequest_Type_RawValue(CafeRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [CafeRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CafeRequest_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum CafeRequest_Type

GPBEnumDescriptor *CafeRequest_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Store\000Unstore\000StoreThread\000UnstoreThread\000"
        "Inbox\000";
    static const int32_t values[] = {
        CafeRequest_Type_Store,
        CafeRequest_Type_Unstore,
        CafeRequest_Type_StoreThread,
        CafeRequest_Type_UnstoreThread,
        CafeRequest_Type_Inbox,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CafeRequest_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CafeRequest_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CafeRequest_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case CafeRequest_Type_Store:
    case CafeRequest_Type_Unstore:
    case CafeRequest_Type_StoreThread:
    case CafeRequest_Type_UnstoreThread:
    case CafeRequest_Type_Inbox:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CafeMessage

@implementation CafeMessage

@dynamic id_p;
@dynamic peer;
@dynamic hasDate, date;
@dynamic attempts;

typedef struct CafeMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t attempts;
  NSString *id_p;
  NSString *peer;
  GPBTimestamp *date;
} CafeMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeMessage_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeMessage__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "peer",
        .dataTypeSpecific.className = NULL,
        .number = CafeMessage_FieldNumber_Peer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = CafeMessage_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CafeMessage__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attempts",
        .dataTypeSpecific.className = NULL,
        .number = CafeMessage_FieldNumber_Attempts,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CafeMessage__storage_, attempts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeMessage class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeClientNonce

@implementation CafeClientNonce

@dynamic value;
@dynamic address;
@dynamic hasDate, date;

typedef struct CafeClientNonce__storage_ {
  uint32_t _has_storage_[1];
  NSString *value;
  NSString *address;
  GPBTimestamp *date;
} CafeClientNonce__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = CafeClientNonce_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeClientNonce__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = CafeClientNonce_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeClientNonce__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = CafeClientNonce_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CafeClientNonce__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeClientNonce class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeClientNonce__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeClient

@implementation CafeClient

@dynamic id_p;
@dynamic address;
@dynamic hasCreated, created;
@dynamic hasSeen, seen;
@dynamic token;

typedef struct CafeClient__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *address;
  GPBTimestamp *created;
  GPBTimestamp *seen;
  NSString *token;
} CafeClient__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeClient_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeClient__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = CafeClient_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeClient__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = CafeClient_FieldNumber_Created,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CafeClient__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "seen",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = CafeClient_FieldNumber_Seen,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CafeClient__storage_, seen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = CafeClient_FieldNumber_Token,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CafeClient__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeClient class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeClient__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeClientList

@implementation CafeClientList

@dynamic itemsArray, itemsArray_Count;

typedef struct CafeClientList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} CafeClientList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CafeClient),
        .number = CafeClientList_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CafeClientList__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeClientList class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeClientList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeToken

@implementation CafeToken

@dynamic id_p;
@dynamic value;
@dynamic hasDate, date;

typedef struct CafeToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSData *value;
  GPBTimestamp *date;
} CafeToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeToken_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeToken__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = CafeToken_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeToken__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = CafeToken_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CafeToken__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeToken class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeClientThread

@implementation CafeClientThread

@dynamic id_p;
@dynamic client;
@dynamic ciphertext;

typedef struct CafeClientThread__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *client;
  NSData *ciphertext;
} CafeClientThread__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeClientThread_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeClientThread__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "client",
        .dataTypeSpecific.className = NULL,
        .number = CafeClientThread_FieldNumber_Client,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeClientThread__storage_, client),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ciphertext",
        .dataTypeSpecific.className = NULL,
        .number = CafeClientThread_FieldNumber_Ciphertext,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CafeClientThread__storage_, ciphertext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeClientThread class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeClientThread__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CafeClientMessage

@implementation CafeClientMessage

@dynamic id_p;
@dynamic peer;
@dynamic client;
@dynamic hasDate, date;

typedef struct CafeClientMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *peer;
  NSString *client;
  GPBTimestamp *date;
} CafeClientMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CafeClientMessage_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CafeClientMessage__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "peer",
        .dataTypeSpecific.className = NULL,
        .number = CafeClientMessage_FieldNumber_Peer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CafeClientMessage__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "client",
        .dataTypeSpecific.className = NULL,
        .number = CafeClientMessage_FieldNumber_Client,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CafeClientMessage__storage_, client),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = CafeClientMessage_FieldNumber_Date,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CafeClientMessage__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CafeClientMessage class]
                                     rootClass:[ModelRoot class]
                                          file:ModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CafeClientMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
